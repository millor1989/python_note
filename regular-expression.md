### 正则表达式

字符串是编程过程中经常遇到的数据类型，对字符串进行的操作很多。

**正则表达式**是一种用来匹配字符串的工具。它的**设计思想**是用一种描述性的语言来给字符串定义一个规则，用规则取“匹配”字符串，符合规则的字符串是匹配的，不符合规则的字符串就是不匹配的。比如，可以定义一个Email地址的正则表达式，来判断一个字符串是否是合法的Email地址。

正则表达式中，如果直接给出了字符就是**精确匹配**。

`\d`可以匹配一个数字，`\w`可以匹配一个字母或数字：

- `'00\d'`可以匹配`'007'`，但是无法匹配`'00A'`
- `'\d\d\d'`可以匹配`'010'`
- `'\w\w\d'`可以匹配`'py3'`

`.`可以匹配任意（一个以上的）字符：

- `'py.'`可以匹配`'pyc'`、`'python'`、`'py!'`等等

对于变长字符：

- 用`*`表示任意个字符（包括0个）
- `+`表示一个以上的字符
- `?`表示0个或1个字符
- `{n}`表示n个字符
- `{n,m}`表示n~m个字符

比如，正则表达式`\d{3}\s+\d{3,8}`，其中：

- `\d{3}`表示3个数字，例如`'010'`
- `\s`可以匹配一个空白字符（空格、Tab等），所以`\s+`表示至少一个的空白字符，例如`'  '`、`'     '`等
- `\d{3,8}`表示3~8个数字，例如`'12345'`，`'234567'`等

如果要匹配`'010-12345'`这样的电话号码，`-`是特殊字符，需要用`\`转义，可以使用正则表达式`\d{3}\-\d{3,8}`来匹配。

#### 1、正则表达式进阶

可以使用`[]`来进行更精确的匹配，比如：

- `[0-9a-zA-Z\_]`可以匹配一个数字、字母或者下划线；
- `[0-9a-zA-Z\_]+`可以匹配至少由一个字母、数字或者下划线组成的字符串，比如`'a234'`，`'0_ax'`，`Python3`等等；
- `[a-zA-Z\_][0-9a-zA-Z\_]*`可以匹配由字母或下划线开头，后接任意个由一个数字、字母或者下划线组成的字符串
- `[a-zA-Z\_][0-9a-zA-Z\_]{0, 19}`更精确地限制了变量的长度是1-20个字符

`A|B`可以匹配A或B，所以`(P|p)ython`可以匹配`'Python'`或者`'python'`。

`^`表示行的开头，`^\d`表示必须以数字开头。

`$`表示行的结束，`\d$`表示必须以数字结束。

`py`可以匹配`'python'`，但是加上`^py$`就变成了**整行匹配**，就只能匹配`'py'`了。

#### 2、`re`模块

Python的`re`模块包含了所有正则表达式的功能。正则表达式使用：

```python
>>> import re
>>> re.match(r'^\d{3}\-\d{3,8}$', '010-12345')
<_sre.SRE_Match object; span=(0, 9), match='010-12345'>
>>> re.match(r'^\d{3}\-\d{3,8}$', '010 12345')
>>>
```

`match()`方法判断是否匹配，如果匹配成功，返回一个`Match`对象，否则返回`None`。

需要注意，Python本身的字符串也是用`\`转义的：

```python
s = 'ABC\\-001' # Python的字符串
# 对应的正则表达式字符串为：
# 'ABC\-001'
```

所以推荐使用Python的`r`前缀，不用考虑转义的问题：

```python
s = r'ABC\-001' # Python的字符串
# 对应的正则表达式字符串仍然是：
# 'ABC\-001'
```

使用正则表达时，`re`模块内部会首先编译正则表达式，如果正则表达式不合法会报错；编译成功后，用编译后的正则表达式去匹配字符串。可以使用`re`模块的编译函数`complie`去预先编译正则表达式：

```python
>>> cre = re.compile('ABC\\\-001')
>>> cre
re.compile(r'ABC\\-001', re.UNICODE)
```

推荐首先进行预编译，再去做匹配，这样就不用重复编译了：

```python
>>> cre.match('ABC\\-001')
<_sre.SRE_Match object; span=(0, 8), match='ABC\\-001'>
```

正则表达式匹配时含有转义字符，是会多次转义的，比如：

```python
>>> re.match('ABC\\\-001', 'ABC\\-001')
<_sre.SRE_Match object; span=(0, 8), match='ABC\\-001'>
```

虽然正则表达式`'ABC\\\-001'`编译后是`r'ABC\\-001'`，匹配时还是会转义一次，实际匹配的是`r'ABC\-001'`：

```python
>>> re.match('ABC\\\-001', r'ABC\-001')
<_sre.SRE_Match object; span=(0, 8), match='ABC\\-001'>
```

#### 3、切分字符串

使用正则表达式可以灵活地切分字符串。

不使用字符串切分字符串：

```python
>>> 'a b   c'.split(' ')
['a', 'b', '', '', 'c']
```

不能识别多个空格，而使用正则表达式：

```python
>>> re.split(r'\s+', 'a b   c')
['a', 'b', 'c']
```

即使是含有`,`，也可以用正则表达式完美切分：

```python
>>> re.split(r'[\s\,]+', 'a,b, c  d')
['a', 'b', 'c', 'd']
```

再有`;`还是没问题的：

```python
>>> re.split(r'[\s\,\;]+', 'a,b;; c  d')
['a', 'b', 'c', 'd']
```

#### 4、分组

正则表达式中加入`()`可以进行分组（Group）提取。

比如`^(\d{3})-(\d{3,8})$`分别定义了两个组：

```python
>>> m = re.match(r'^(\d{3})-(\d{3,8})$', '010-12345')
>>> m
<_sre.SRE_Match object; span=(0, 9), match='010-12345'>
>>> m.group(0)
'010-12345'
>>> m.group(1)
'010'
>>> m.group(2)
'12345'
```

分组`group(0)`是原始字符串，`group(1)`、`group(2)`则对应第1、第2个分组对应的字符串。

用分组来提取字符串非常有用，比如提取时分秒：

```python
>>> t = '19:05:30'
>>> m = re.match(r'^(0[0-9]|1[0-9]|2[0-3]|[0-9])\:(0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]|[0-9])\:(0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]|[0-9])$', t)
>>> m.groups()
('19', '05', '30')
```

`groups()`方法，将各个子字符串作为`tuple`返回。

但是，注意，对于非法的时间，比如`'33:99:99'`，是不能起作用了。

#### 5、贪婪匹配

正则匹配默认是**贪婪匹配**，会匹配尽可能多的字符。比如，匹配数字后面的`0`：

```python
>>> re.match(r'^(\d+)(0*)$', '102300').groups()
('102300', '')
```

由于`\d+`采用贪婪匹配，直接把后面的`0`全部匹配了，结果`0*`只能匹配到空字符串。

`\d+`后面加`?`可以使其转换为非贪婪匹配（匹配尽可能少的字符）：

```python
>>> re.match(r'^(\d+?)(0*)$', '102300').groups()
('1023', '00')
```

